"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utility = void 0;
const PlatformTools_1 = require("../platform/PlatformTools");
const globals_1 = require("../globals");
const mongoose_1 = __importDefault(require("mongoose"));
const ValidationUtils_1 = require("./ValidationUtils");
class Utility {
    /**
     * Generate Swagger Schema Definition
     */
    static genSchemaDef(obj) {
        let props = {};
        for (const prop of obj.props) {
            props = Object.assign({
                [prop.prop]: {
                    type: prop.type,
                    example: prop.example,
                    description: prop.description,
                    required: prop.required,
                },
            }, props);
        }
        return {
            [obj.name]: {
                type: 'object',
                properties: props,
            },
        };
    }
    /**
     * Extracts Swagger Schema Object from JSON
     * @param swagger JSON Document
     * @params schema: new swaggified schemas
     * @returns schema object
     */
    static updateSchema(swaggerDoc, schema) {
        const parsed = JSON.parse(swaggerDoc.toString());
        parsed.swaggerDefinition.definitions = schema;
        return JSON.stringify(parsed, null, 2);
    }
    /**
     * Extracts Swagger Schema Object from JSON
     * @param swagger JSON Document
     * @params schema: new swaggified schemas
     * @returns schema object
     */
    static updateAPIDefinition(swaggerDoc, apiDefinition) {
        const parsed = JSON.parse(swaggerDoc.toString());
        parsed.swaggerDefinition.paths = apiDefinition;
        return JSON.stringify(parsed, null, 2);
    }
    /**
     * Generates swagger file from schemas
     * @params schema
     * @returns Promise<void>
     */
    static async swaggiffy(schema, type) {
        return new Promise((ok, fail) => {
            const swaggerDoc = PlatformTools_1.PlatformTools.getFileContents(Utility.configStore.swaggerDefinitionFilePath);
            let definition = '';
            if (type === 'DEFINITION')
                definition = this.updateAPIDefinition(swaggerDoc, schema);
            else if (type === 'SCHEMA')
                definition = this.updateSchema(swaggerDoc, schema);
            PlatformTools_1.PlatformTools.writeToFile(Utility.configStore.swaggerDefinitionFilePath, definition);
            ok();
        });
    }
    /**
     * Converts SchemaMetadata[] to plain JSON Object
     * @param array SchemaMetadata array
     * @returns JSON defined SwaggerSchema
     */
    static toSwaggerSchema(array) {
        let definition = {};
        for (const item of array) {
            definition = {
                ...definition,
                ...{ [item.name]: item.swaggerDefinition[item.name] },
            };
        }
        return definition;
    }
    /**
     * Converts APIDefinitionMetadata[] to plain JSON Object
     * @param array APIDefinitionMetadata array
     * @returns JSON defined SwaggerSchema
     */
    static toSwaggerAPIDefinition(array) {
        let apiDefinition = {};
        const pathStrings = array.map((item) => item.apiDefinition.pathString);
        const uniquePathStrings = Array.from(new Set(pathStrings));
        for (const pathString of uniquePathStrings) {
            const methods = array.filter((item) => item.apiDefinition.pathString === pathString);
            let apiDefinerObj = {};
            for (const method of methods) {
                apiDefinerObj = {
                    ...apiDefinerObj,
                    ...{
                        [method.apiDefinition.method]: {
                            tags: method.apiDefinition.tags,
                            operationId: method.apiDefinition.meta.operationId,
                            summary: method.apiDefinition.meta.summary,
                            description: method.apiDefinition.meta.description,
                            parameters: method.apiDefinition.meta.parameters,
                            consumes: method.apiDefinition.meta.consumes,
                            produces: method.apiDefinition.meta.produces,
                            responses: method.apiDefinition.meta.responses,
                            security: method.apiDefinition.meta.security,
                        },
                    },
                };
            }
            apiDefinition = {
                ...apiDefinition,
                ...{
                    [ValidationUtils_1.ValidationUtils.cleanSwaggerPathString(pathString)]: {
                        ...apiDefinerObj,
                    },
                },
            };
        }
        return apiDefinition;
    }
    static extractType(func) {
        const str = func.toString();
        if (str.toLowerCase().includes('string'))
            return 'string';
        else if (str.toLowerCase().includes('number'))
            return 'number';
        else if (str.toLowerCase().includes('boolean'))
            return 'boolean';
        else if (str.toLowerCase().includes('date'))
            return 'string';
        else if (str.toLowerCase().includes('objectid'))
            return 'string';
        else if (str.toLowerCase().includes('uuid'))
            return 'string';
    }
    static castMongooseType(type) {
        switch (type) {
            case mongoose_1.default.Schema.Types.String.schemaName:
                return ['string', undefined, undefined, 'string'];
            case mongoose_1.default.Schema.Types.Number.schemaName:
                return ['number', undefined, undefined, 0];
            case mongoose_1.default.Schema.Types.Date.schemaName:
                return ['string', 'date', undefined, new Date().toLocaleString()];
            case mongoose_1.default.Schema.Types.Boolean.schemaName:
                return ['boolean', undefined, undefined, false];
            case mongoose_1.default.Schema.Types.Buffer.schemaName:
                return ['object', undefined, undefined, undefined];
            case mongoose_1.default.Schema.Types.Mixed.schemaName:
                return ['object', undefined, undefined, undefined];
            case 'ObjectID':
                return ['string', undefined, true, '507f1f77bcf86cd799439011'];
            case mongoose_1.default.Schema.Types.Array.schemaName:
                return ['array', undefined, undefined, undefined];
            case mongoose_1.default.Schema.Types.Map.schemaName:
                return ['object', undefined, undefined, undefined];
            default:
                return ['object', undefined, undefined, undefined];
        }
    }
    static castSequelizeType(type) {
        console.log(type);
        switch (type) {
            case 'STRING':
                return ['string', undefined, undefined, 'string'];
            case 'TEXT':
                return ['string', undefined, undefined, 'string'];
            case 'CITEXT':
                return ['number', undefined, undefined, 0];
            case 'DATE':
                return ['string', 'date', undefined, new Date().toLocaleString()];
            case 'DATEONLY':
                return ['string', 'date', undefined, new Date().toLocaleString()];
            case 'UUID':
                return ['string', 'uuid', undefined, '78a208e0-01fc-4cc0-b533-de8c076a6bf8'];
            case 'UUIDV4':
                return ['string', 'uuid', undefined, '78a208e0-01fc-4cc0-b533-de8c076a6bf8'];
            case 'BOOLEAN':
                return ['boolean', undefined, undefined, false];
            case 'FLOAT':
                return ['number', 'float', undefined, 0.0];
            case 'DOUBLE':
                return ['number', 'double', undefined, 0.0];
            case 'BIGINT':
                return ['number', undefined, undefined, 0.0];
            case 'DECIMAL':
                return ['number', 'float', true, 0.0];
            case 'INTEGER':
                return ['number', undefined, true, 0.0];
            default:
                return ['object', undefined, undefined, undefined];
        }
    }
    static castJSType(type) {
        switch (type) {
            case 'string':
                return ['string', undefined];
            case 'number':
                return ['number', undefined];
            case 'bigint':
                return ['number', undefined];
            case 'boolean':
                return ['boolean', undefined];
            case 'symbol':
                return ['object', undefined];
            case 'undefined':
                return ['object', undefined];
            case 'object':
                return ['object', undefined];
            case 'function':
                return ['object', undefined];
            default:
                return ['object', undefined];
        }
    }
}
exports.Utility = Utility;
/**
 * Returns target Class properties
 * @param _class
 * @returns Target class properties
 */
Utility.configStore = (0, globals_1.getConfigMetadataStorage)();
//# sourceMappingURL=Utility.js.map